###27433###
팩토리얼 수를 재귀로 구하는 문제이다. 제한시간은 1초지만 입력의 제한이 20까지라서 그냥 재귀로 풀면 된다. 
근데 한 번 틀렸는데 20의 팩토리얼의 수가 int의 범위를 벗어나서 한 번 틀렸다. 그치만 바로 파악했다. 

###10870###
피보나치 수를 구하는 문제이다. 똑같이 제한시간은 1초이지만 입력의 제한이 20이라서 그냥 재귀로 풀면 된다. 문제없었다. 

###25501###
특정 문자열이 들어왔을 때 팰린드롬인지 확인하는 문제이다. 2초로 제한시간도 넉넉한 편이고 입력의 제한도 1000글자 이내라서 많아봐도 
500번의 재귀만 반복될텐데 단순하게 그냥 재귀로 코드를 제출하면 시간초과가 난다. 뭐가 문제일까 생각도 안하고 바로 질문게시판을 봤다. 
문제는 재귀함수를 들어가면서 string& 으로 참조값을 넘기면 되는데 그냥 string으로 넘겨서 문자열이 재귀가 반복될 때마다 복사가 되어서 
오래 걸리는 것이었다. 생각보다 간단했는데 고민 시도조차 안하고 그냥 바로 질문게시판을 본 내 자신을 반성하게 되었다. 그리고 별 것 아닌 
것 같은 부분에서도 크게 시간 차이가 나니까 이런 부분은 습관화 하는 것이 좋을 것 같다. 

###24060###
merge sort 함수에서 배열이 정렬되는 순서에 따라 특정 순간에 정렬되는 숫자를 출력하면 되는 문제이다. merge sort 자체는 어렵지 않은데 index
를 잘 계산해야 될 것 같다. 처음에 좀 가볍게 생각했다가 outOfBound 오류가 몇 번 발생했다. 

###4779###
칸토어 집합이라는 문제이다. 재귀의 핵심을 재귀를 따라 들어가지 않는 것이다. n==0 일 지점에 대한 분기 처리를 해주고나면 n-1 부터 아래 단계는
알아서 진행된다고 판단하고 현재 단계에만 집중하는 것이다. 

###11729###
재귀 문제를 풀 때 가장 중요한 점은 재귀를 따라 들어가지 않는 것이다. n 번째 문제를 풀 때 n-1의 과정은 컴퓨터가 알아서 해준다고 여기고 현재 
단계의 문제를 푸는 데에만 집중하면 된다. 그리고 n==0일 지점의 분기 처리를 해주면 된다. 이 문제가 골드 5이지만 이러한 사실에 집중해서 풀면 
굉장히 쉽다. 몰론 하노이 탑을 어떤 식으로 풀면되는지 수학적 귀납식을 세우는 과정이 필요하다. 그것만 세우고나면 재귀의 이러한 특성에 집중해서
풀면 쉽게 풀린다. 

###1074###
4시간 동안 이 문제만 붙잡고 있었다. 나름 새로 깨달은 점이 많은 문제였다. 처음엔 2^15 * 2^15 크기의 배열을 생성하고 찾으려는 r,c 값에 해당하는
부분만 재귀적으로 계산하면서 하면 시간복잡도를 지킬 수 있지 않을까 싶었는데 메모리 제한을 생각하지 않았다. 그래서 3시간 날려먹었다. 겨우 다 짰는데
메모리 땜에 안될 것 이란것 알았다. 메모리는 2^15 * 2^15 * 32 (Int형이라서 32 bit)크기인데 제한이 512MB라서 안된다. 그래서 그냥 배열 전체를 생성
하진 않고 재귀적으로 범위를 줄여나가서 출력하기만 하도록 했다. 문제 풀 때 시간복잡도 뿐만 아니라 메모리 제한도 잘보자. 