9657 실버3
전형적인 DP 문제이다. 김성열 교수님의 알고리즘 수업을 들었다면 알 수 있는 DP 문제이다. 왜 DP일까? 선택에 따라 흘러가는 경우의 수가 다르다. 베스킨라빈스 31의 전형적인 유형이다. 그래서 DP임을 알았다. 푸는 법은 간단하게 n번째의 경우의 수를 구하려면 어떻게 해야하는지 집합 나누기를 했고 집합을 나누었을 때 해당 경우가 n보다 작은 경우에서 구할 수 있었다. 즉 기억하며 풀기가 적용되는 문제이고 DP가 되는 것이다. Top To Bottom으로 재귀를 통해 풀어도 되지만 난 Bottom to Top을 통해 base 값을 두고 반복문으로 i 번째를 채워가는 방식으로 진행했다. 

1351 골드5
그냥 배열로 브루트포스 풀면 메모리 초과, 시간초과가 난다. 재귀로 그냥 풀면 시간초과가 난다. DP를 사용해서 중복된 값을 제거하고 싶은데 DP값을 저장할 자료구조로 배열을 사용하면 메모리 초과가 난다. 그럼 다른 자료구조를 쓰면 된다. Map 을 써서 DP 값을 저장하면 된다. —> DP 값을 저장하는데에 꼭 배열이 아니라 다른 자료 구조로 저장해도 된다. 
Bottom To Top 이면 필요하지 않은 인덱스도 계산해야하지만 재귀를 사용해서 Top To Bottom으로  접근하면 필요한 부분만 호출하게 되니까 좋다. 

1003 실버3
딱보고 DP 임을 알았다. 예전에 메모 써진 걸 보니 그 당시엔 무지성으로 0일 때 1일때 2일 때 계산하다보니 피보나치를 따르게 되어서 피보나치를 계산하려고 DP 를 썼다고 한다. 근데 이번에 풀 땐 달랐다. 김성열 교수님이 알려준대로 n 번째를 구하기 위해서 집합 나누기를 적용했고 그러다 보니 f(n)은 f(n-1)과 f(n-2)를 호출하는 것을 알아내었고 그러면 0의 개수도 f(n-1)에서의 0의 개수와 f(n-2)에서의 0의 개수임을 일테고 1의 개수도 마찬가지이다. 그래서 DP임을 알아채었다.

1012 실버2 (DFS)
딱보고 DFS임을 알았다. 근데 푸는 과정에서 멍청한 실수를 조금 해서 삽질 좀 하고 2차원 배열을 초기화하는 부분에서 런타임 에러가 조금 났다. 그거 외엔 그냥 전형적인 DFS 문제. 개념적으로 어려운건 없엇다. 그냥 내 구현이 문제가 조금 있었을 뿐