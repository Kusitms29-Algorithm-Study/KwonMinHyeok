###16549###
그냥 수열에서 중복값을 제외하여 뽑는 모든 경우를 출력하는 문제이다. 입력의 범위가 8이하라서 8! 연산을 해도 1초 안에 가능하기 때문에 브루트포스로 진행하면 된다. 
단 이것을 재귀를 활용해서 백트래킹하는 방법으로 풀면 된다. 백트래킹의 가장 단순한 형태로 배열에서 index를 줄여가면서 모든 경우를 탐색해야하는 경우에 사용하면 된다. 

###15650###
위의 문제의 변형 형태로, 오름차순으로 출력해야 한다. 기존 코드에서 재귀 함수 안 for의 시작지점을 고쳐서 풀었다. 

###15651###
첫번째 문제의 변형 형태로, 중복을 허용한다. 그래서 첫번째 코드에서 check 배열을 판단하는 부분을 주석처리해주었다. 

###15652###
첫번째 문제의 변형 형태로, 비내림차순이어야 한다. 비내림차순이란 오름차순인데 중복을 허용하는 형태이다. 그래서 세번째 코드와 두번째 코드를 둘 다 적용해서 풀었다.

###9663###
백트래킹의 전형적인 대표 문제로 N-Queen 문제이다. 예전에 풀었을 때 처음 접근했던 방식이 계속 시간초과가 났었는데 그때와 똑같은 방식으로 접근했다. 
시간초과가 나진 않았지만 당시에 막혔던 부분에서 똑같이 막혀서 '아 이렇게 풀면 안되지' 라고 생각했다. 2차원 배열을 선언해두고 한 행씩 접근하면서 
한 행에 queen을 놓을 때마다 2차원 배열에서 더이상 놓을 수 없는 부분을 marking 하는 방식으로 진행했다. 근데 그러면 marking 하는데 시간이 오래 걸릴 
뿐더러, 대각선을 check하는 로직이 복잡해진다. 
왜 굳이 2차원 배열이어야 하는가? 그럴 필요없다. 애초에 한 행씩 접근하기 때문에 이전 행은 marking 할 필요가 없다. 내가 현재 보는 한 행만 보면 된다. 
그래서 1차원 배열로도 충분히 풀 수 있다. 대각선 로직은 차근차근 생각해보면 1차원 배열에서의 규칙이 보일 것이다. 나중엔 똑같이 풀지 말자.

###2580###
스도쿠를 백트래킹으로 푸는 문제이다. 입력이 9x9로 정해져 있어서 그냥 브루트포스로 풀면 된다. 주의해야할 점을 보자면 3x3 크기에서 유효한 숫자인가
를 판다하는 것인데 그냥 생각한 그대로 시작점 잡고 이중 for문으로 해결했다. 그냥 생각한 그대로 풀면 된다. 그리고 처음 제출했을 때 한 번 틀렸는데
재귀의 종료 조건을 만족하면 출력하고 프로그램을 종료시켜야 하는데 그러지 않고 그냥 함수 return 만 해서 가능한 모든 스도쿠 조합을 다 출력하는 바람
에 한 번 틀렸다.